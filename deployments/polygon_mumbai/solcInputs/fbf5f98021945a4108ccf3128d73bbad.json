{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v4.8.0/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_router;\n\n  constructor(address router) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_router = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return i_router address\n  function getRouter() public view returns (address) {\n    return address(i_router);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != address(i_router)) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // extraArgs will evolve to support new features\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\n    bool strict; // See strict sequencing details below.\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n}"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n    * @dev Returns true if this contract implements the interface defined by\n    * `interfaceId`. See the corresponding\n    * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n    * to learn more about how these ids are created.\n    *\n    * This function call must use less than 30 000 gas.\n    */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/StudioAlias.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\npragma solidity ^0.8.20;\r\n\r\ncontract StudioAlias {\r\n\r\n    struct Alias {\r\n        string _alias;\r\n        string _avatarURI;\r\n        bool isSet;\r\n    }\r\n\r\n    event AliasEvent (\r\n        bytes32 indexed id,\r\n        address indexed account,\r\n        string _alias,\r\n        string _avatarURI\r\n    );\r\n\r\n    mapping (address => Alias) public aliases;\r\n    constructor() {\r\n        \r\n    }\r\n\r\n    function setAlias(string memory _alias_, string memory _avatarURI_) public {\r\n        bytes32 id = keccak256(abi.encodePacked(msg.sender, _alias_, _avatarURI_));\r\n\r\n        aliases[msg.sender] = Alias(_alias_, _avatarURI_, true);\r\n\r\n        emit AliasEvent(id, msg.sender, _alias_, _avatarURI_);\r\n    }\r\n\r\n    function getAlias(address account) public view returns (string memory) {\r\n        string memory _alias = aliases[account]._alias;\r\n\r\n        return _alias;\r\n    }\r\n\r\n    function getAliasURI(address account) public view returns (string memory){\r\n        string memory _aliasURI = aliases[account]._avatarURI;\r\n\r\n        return _aliasURI;\r\n    }\r\n\r\n    function isAliasSet(address account) public view returns (bool) {\r\n        bool _aliasStatus = aliases[account].isSet;\r\n        \r\n        if(_aliasStatus) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}"
    },
    "contracts/StudioRegister.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./StudioAlias.sol\";\r\nimport \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/token/ERC20/IERC20.sol\";\r\nimport \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\r\n\r\ncontract StudioRegister is CCIPReceiver, StudioAlias {\r\n    string public chain;\r\n    StudioAlias public _studioAlias;\r\n\r\n    struct Studio {\r\n        bytes32 studioId;\r\n        string studioName;\r\n        string thumbnailURI;\r\n        string avatarURI;\r\n        string chain;\r\n        string descriptiveText;\r\n        string creatorAlias;\r\n        address creator;\r\n        address studioAddress;\r\n        address nftAddress;\r\n        address tokenAddress;\r\n    }\r\n\r\n    event StudioEvent (\r\n        bytes32 indexed studio_id,\r\n        string indexed studioName,\r\n        string thumbnailURI,\r\n        string avatarURI,\r\n        string chain,\r\n        string descriptiveText,\r\n        string creatorAlias,\r\n        address creator,\r\n        address indexed studioAddress,\r\n        address studioTokenAddress,\r\n        address nftAddress\r\n    );\r\n\r\n    mapping (address => Studio) public studioMap;\r\n\r\n    constructor(address _aliasContract, address _router) CCIPReceiver(_router) {\r\n        _studioAlias = StudioAlias(_aliasContract);\r\n    }\r\n\r\n    // CCIP call - called from receive function.\r\n    function logStudio(\r\n        string memory _name,\r\n        string memory _thumbnailURI,\r\n        string memory _avatarURI,\r\n        string memory _chain,\r\n        string memory _descriptiveText,\r\n        address _creator,\r\n        address _studio,\r\n        address _nft,\r\n        address _token\r\n    ) public {\r\n\r\n        bytes32 id = keccak256(\r\n            abi.encodePacked(_name, _thumbnailURI, _avatarURI, _chain, _descriptiveText, _creator, _studio, _token)\r\n        );\r\n\r\n        string memory _creatorAlias = getAddressedAlias(_creator);\r\n\r\n        studioMap[_creator] = Studio(id, _name, _thumbnailURI, _avatarURI, _chain, _descriptiveText, _creatorAlias, _creator, _studio, _nft, _token);\r\n\r\n        emit StudioEvent(id, _name, _thumbnailURI, _avatarURI, _chain, _descriptiveText, _creatorAlias, _creator, _studio, _token, _nft);\r\n    }\r\n\r\n    function getStudio(address creator) public view returns (Studio memory) {\r\n        Studio memory studio = studioMap[creator];\r\n\r\n        return studio;\r\n    }\r\n\r\n    // CCIP - called in receive\r\n    function getStudioName(address creator) public view returns (string memory) {\r\n        Studio memory studio = getStudio(creator);\r\n\r\n        return studio.studioName;\r\n    }\r\n    // CCIP - called in receive\r\n    function getStudioAddress(address creator) public view returns (address) {\r\n        Studio memory studio = getStudio(creator);\r\n\r\n        return studio.studioAddress;\r\n    }\r\n\r\n    // CCIP - called in receive\r\n    function getStudioTokenAddress(address creator) public view returns (address) {\r\n        Studio memory studio = getStudio(creator);\r\n\r\n        return studio.nftAddress;\r\n    }\r\n\r\n    function getStudioNftAddress(address creator) public view returns (address) {\r\n        Studio memory studio = getStudio(creator);\r\n\r\n        return studio.nftAddress;\r\n    }\r\n\r\n    function getStudioChain(address creator) public view returns (string memory) {\r\n        Studio memory studio = getStudio(creator);\r\n\r\n        return studio.chain;\r\n    }\r\n\r\n    function _setAlias(string memory _alias, string memory _avatarURI) public {\r\n        _studioAlias.setAlias(_alias, _avatarURI);\r\n    }\r\n\r\n    function _getAlias() public view returns (string memory ) {\r\n       return  _studioAlias.getAlias(msg.sender);\r\n    }\r\n\r\n    function getAddressedAlias(address account) public view returns (string memory) {\r\n        return  _studioAlias.getAlias(account);\r\n    }\r\n\r\n    function getAddressedAvatar(address account) public view returns (string memory) {\r\n        return  _studioAlias.getAliasURI(account);\r\n    }\r\n\r\n    function _getAliasAvatar() public view returns (string memory ) {\r\n       return  _studioAlias.getAliasURI(msg.sender);\r\n    }\r\n\r\n    function _isAliasSet() public view returns (bool) {\r\n        return _studioAlias.isAliasSet(msg.sender);\r\n    }\r\n\r\n    function _ccipReceive(\r\n        Client.Any2EVMMessage memory message\r\n    ) internal virtual override {\r\n        (string memory studioName, \r\n        string memory thumbnailURI, \r\n        string memory avatarURI, \r\n        string memory _chain, \r\n        string memory descriptiveText,\r\n        address _creator, \r\n        address studioAddress, \r\n        address nftAddress,\r\n        address tokenAddress ) = abi.decode(message.data, (string, string, string, string, string, address, address, address, address));\r\n\r\n        logStudio(studioName, thumbnailURI, avatarURI, _chain, descriptiveText, _creator, studioAddress, nftAddress, tokenAddress);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}